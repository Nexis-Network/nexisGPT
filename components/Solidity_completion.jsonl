{"completion": "```solidity\npragma solidity ^0.8.0;\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\n\ncontract CustomToken is ERC20, Ownable, Pausable {\n constructor(string memory name, string memory symbol, uint256 initialSupply) ERC20(name, symbol) {\n _mint(msg.sender, initialSupply);\n }\n\n function mint(address to, uint256 amount) public onlyOwner whenNotPaused {\n _mint(to, amount);\n }\n\n function burn(uint256 amount) public {\n _burn(msg.sender, amount);\n }\n\n function pause() public onlyOwner {\n _pause();\n }\n\n function unpause() public onlyOwner {\n _unpause();\n }\n}\n```"}
{"completion": "```solidity\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract MyNFT is ERC721, Ownable {\n uint256 public tokenCounter;\n string public baseTokenURI;\n\n constructor(string memory name, string memory symbol, string memory baseURI) ERC721(name, symbol) {\n tokenCounter = 0;\n baseTokenURI = baseURI;\n }\n\n function mintNFT(address to) public onlyOwner {\n _safeMint(to, tokenCounter);\n tokenCounter++;\n }\n\n function _baseURI() internal view virtual override returns (string memory) {\n return baseTokenURI;\n }\n}\n```"}
{"completion": "```solidity\npragma solidity ^0.8.0;\nimport \"@layerzero/contracts/interfaces/ILayerZeroEndpoint.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\ncontract CrossChainToken is ERC20 {\n ILayerZeroEndpoint public endpoint;\n\n constructor(string memory name, string memory symbol, address _endpoint) ERC20(name, symbol) {\n endpoint = ILayerZeroEndpoint(_endpoint);\n }\n\n function sendTokens(address to, uint256 amount, uint16 dstChainId) public {\n _burn(msg.sender, amount);\n bytes memory payload = abi.encode(to, amount);\n endpoint.send(dstChainId, payload);\n }\n\n function receiveTokens(bytes memory payload) public {\n (address to, uint256 amount) = abi.decode(payload, (address, uint256));\n _mint(to, amount);\n }\n}\n```"}
{"completion": "```solidity\npragma solidity ^0.8.0;\nimport \"@openzeppelin/contracts/token/ERC1155/ERC1155.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract NFTMarketplace is ERC1155, Ownable {\n mapping(uint256 => uint256) public prices;\n mapping(uint256 => bool) public isForSale;\n\n constructor(string memory uri) ERC1155(uri) {}\n\n function setPrice(uint256 tokenId, uint256 price) public onlyOwner {\n prices[tokenId] = price;\n isForSale[tokenId] = true;\n }\n\n function buy(uint256 tokenId) public payable {\n require(isForSale[tokenId], \"Token not for sale\");\n require(msg.value == prices[tokenId], \"Incorrect price\");\n safeTransferFrom(owner(), msg.sender, tokenId, 1, \"\");\n }\n}\n```"}
{"completion": "```solidity\npragma solidity ^0.8.0;\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract StakingToken is ERC20, Ownable {\n mapping(address => uint256) public stakedBalances;\n uint256 public totalStaked;\n\n constructor(string memory name, string memory symbol) ERC20(name, symbol) {}\n\n function stake(uint256 amount) public {\n require(balanceOf(msg.sender) >= amount, \"Insufficient balance\");\n _transfer(msg.sender, address(this), amount);\n stakedBalances[msg.sender] += amount;\n totalStaked += amount;\n }\n\n function withdrawStake(uint256 amount) public {\n require(stakedBalances[msg.sender] >= amount, \"Insufficient staked balance\");\n stakedBalances[msg.sender] -= amount;\n totalStaked -= amount;\n _transfer(address(this), msg.sender, amount);\n }\n}\n```"}
{"completion": "```solidity\npragma solidity ^0.8.0;\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract GovernanceToken is ERC20, Ownable {\n mapping(address => uint256) public delegatedVotes;\n\n constructor(string memory name, string memory symbol, uint256 initialSupply) ERC20(name, symbol) {\n _mint(msg.sender, initialSupply);\n }\n\n function delegateVotes(address to, uint256 amount) public {\n require(balanceOf(msg.sender) >= amount, \"Insufficient balance\");\n _transfer(msg.sender, to, amount);\n delegatedVotes[to] += amount;\n }\n}\n```"}
{"completion": "```solidity\npragma solidity ^0.8.0;\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract TimeLockedVault is Ownable {\n ERC20 public token;\n uint256 public releaseTime;\n\n constructor(ERC20 _token, uint256 _releaseTime) {\n token = _token;\n releaseTime = _releaseTime;\n }\n\n function withdraw() public onlyOwner {\n require(block.timestamp >= releaseTime, \"Vault is still locked\");\n uint256 balance = token.balanceOf(address(this));\n token.transfer(owner(), balance);\n }\n}\n```"}
{"completion": "```solidity\npragma solidity ^0.8.0;\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\n\ncontract PriceFeedConsumer {\n AggregatorV3Interface internal priceFeed;\n\n constructor(address _priceFeed) {\n priceFeed = AggregatorV3Interface(_priceFeed);\n }\n\n function getLatestPrice() public view returns (int) {\n (, int price,,,) = priceFeed.latestRoundData();\n return price;\n }\n}\n```"}
{"completion": "```solidity\npragma solidity ^0.8.0;\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract TokenSwap is Ownable {\n ERC20 public token1;\n ERC20 public token2;\n uint256 public rate; // Tokens exchanged per unit\n\n constructor(ERC20 _token1, ERC20 _token2, uint256 _rate) {\n token1 = _token1;\n token2 = _token2;\n rate = _rate;\n }\n\n function swap(uint256 amount) public {\n require(token1.balanceOf(msg.sender) >= amount, \"Insufficient token1 balance\");\n uint256 exchangeAmount = amount * rate;\n require(token2.balanceOf(address(this)) >= exchangeAmount, \"Insufficient token2 balance\");\n token1.transferFrom(msg.sender, address(this), amount);\n token2.transfer(msg.sender, exchangeAmount);\n }\n}\n```"}
{"completion": "```solidity\npragma solidity ^0.8.0;\nimport \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract NFTAuction is ERC721, Ownable {\n struct Auction {\n uint256 tokenId;\n address payable seller;\n uint256 reservePrice;\n bool active;\n }\n mapping(uint256 => Auction) public auctions;\n\n constructor(string memory name, string memory symbol) ERC721(name, symbol) {}\n\n function createAuction(uint256 tokenId, uint256 reservePrice) public onlyOwner {\n auctions[tokenId] = Auction(tokenId, payable(msg.sender), reservePrice, true);\n _transfer(msg.sender, address(this), tokenId);\n }\n}\n```"}
{"completion": "```solidity\npragma solidity ^0.8.0;\nimport \"@openzeppelin/contracts/token/ERC1155/ERC1155.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract BatchMintNFT is ERC1155, Ownable {\n constructor(string memory uri) ERC1155(uri) {}\n\n function mintBatch(address to, uint256[] memory ids, uint256[] memory amounts, bytes memory data) public onlyOwner {\n _mintBatch(to, ids, amounts, data);\n }\n}\n```"}
{"completion": "```solidity\npragma solidity ^0.8.0;\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\ncontract SecureWithdrawals is ReentrancyGuard {\n mapping(address => uint256) public balances;\n\n function deposit() public payable {\n balances[msg.sender] += msg.value;\n }\n\n function withdraw(uint256 amount) public nonReentrant {\n require(balances[msg.sender] >= amount, \"Insufficient balance\");\n balances[msg.sender] -= amount;\n payable(msg.sender).transfer(amount);\n }\n}\n```"}
{"completion": "```solidity\npragma solidity ^0.8.0;\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract StakingRewards is ERC20, Ownable {\n mapping(address => uint256) public staked
